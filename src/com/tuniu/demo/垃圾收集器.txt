1、Serial收集器
	Serial收集器是最基本、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择，这个收集器是
一个单线程的收集器，但它 的“单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程去完成垃圾收 集工作，更重要的是在它
进行垃圾收集时，必须暂停其他所有的工作线程（Sun将这件事情 称之为“Stop The World”），直到它收集结束。“Stop The
World”这个名字也许听 起来很酷，但这项 工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见 的情况下把用户的正常工作
的线程全部停掉，这对很多应用来说都是难以接受的。笔者似乎已经把Serial收集器描述成一个老而无用，食之无味弃之可惜 的鸡肋了，
但实际上到现在为止，它依然是虚拟机运行在Client模式下的默认新生代收 集器。它也有着优于其他收集器的地方：简单而高效（与其他
收集器的单线程比），对 于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收 集自然可以获得最高的
单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理 的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代
使用的 内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫 秒以内，只要不是频繁发生，这点停顿是可以接受的。
所以，Serial收集器对于运行在 Client模式下的虚拟机来说是一个很好的选择。

2、ParNew收集器
	ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾 收集之外，其余行为包括Serial收集器可用的所有控制参数
（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure 等）、收集算法
、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，实现上这两种收集器也 共用了相当多的代码。
ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之 处，但它却是许多运行在Server模式下的虚拟机中
首选的新生代收集器，其中有一个与 性能无关但很重要的原因是，除了 Serial收集器外，目前只有它能与CMS收集器配合 工作。在JDK1.5
时期，HotSpot推出了一款在强交互应用中几乎可称为有划时代意义 的垃圾收集器――CMS收集器（Concurrent Mark Sweep），
这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent)收集器， 它第一次实现了让垃圾收集线程与用户线程（基本上）
同时工作。不幸的是，它作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收 集器Parallel Scavenge配合工作,
所以在JDK 1.5中使用CMS来收集老年代的时 候，新生代只能选择ParNew或Serial收集器中的一个。ParNew收集器也是使用
-XX: +UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC 选项来强制指定它。
ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于 存在线程交互的开销，该收集器在通过超线程技术
实现的两个CPU的环境中都不能百分之 百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时 系统资源
的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU 非常多（譬如32个，现在CPU动辄就4核加超线程，服务器
超过32个逻辑CPU的情况 越来越多了）的环境下，可以使用-XXfaralldGCThreads参数来限制垃圾收集的线程数。注意从ParNew
收集器开始，后面还将会接触到几款并发和并行的收集器。
在大家可能 产生疑惑之前，有必要先解释两个名词：并发和并行。
这两个名词都是并发编程中的概 念，在谈论垃圾收集器的上下文语境中，他们可以解释为：
并行（Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 
并发（Concurrent):指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能 会交替执行），用户程序继续运行，
而垃圾收集程序运行于另一个CPU上。


3、 Parallel Scavenge收集器
Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器， 又是并行的多线程收集器，看上去和ParNew都一样
，那它有什么特e之处呢？Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的 关注点尽可能地缩短垃圾
收集时用户线程的停顿时间，而Parallel Scavenge收集器的目 标则是达到一个可控制的吞吐景（Throughput)。所谓淄铝烤褪
CPU用于运行用户代 码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时 间+垃圾收集时间），虚拟机总共运行了
100分钟，其中垃圾收集花掉1分钟，那吞吐 量就是99%。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体 验；
而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适 合在后台运算而不需要太多交互的任务。Parallel Scavenge
收集器提供了两个参数用干精确控制吞吐量，分别是控制 最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数及直接设置吞吐量大小的
-XX:GCTimeRatio 参数。MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回 收花费的时间不超过
设定值。不过大家不要异想天开地认为如果把这个参数的值设置得 稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和
 新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB 快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒
 收集一次、每次停顿1 毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也 降下来了。GCTimeRatio参数
 的值应当是一个大于0小于100的整数，也就是垃圾收集时间占 总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19,那允许的最大GC
 时 间就占总时间的5% (即1 / (1 + 19)),默认值为99,就是允许最大1% (即1 / (1+99)) 的垃圾收集时间。由于与吞吐量关系
 密切，Parallel Scavenge收集器也经常被称为“吞吐量 优先”收集器。除上述两个参数之外，Parallel Scavenge收集器还有
 一个参数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就 不需要手动指定新生代的大小（-Xmn)
 、Eden与Survivor区的比例（-XX:SurvivorRatio)、 晋升老年代对象年龄（-XXfretemireSizeThreshold)
 等细节参数了，虚拟机会根据当 前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或 最大的吞吐量，这种调节方式
 称为GC自适应的调节策略（GC Ergonomics).。如果 读者对于收集器运作原理不太了解，手工优化存在困难的时候，使用Parallel
Scavenge 收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个很 不错的选择。只需要把基本的内存数据设置好
（如-Xmx设置最大堆），然后使用 MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio参数（更关注吞吐量） 给虚拟机
设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调 节策略也是Parallel Scavenge收集器与ParNew收集器
的一个重要区e。


4 Serial Old 收集器
Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标 记-整理”算法。这个收集器的主要意义也是被Client
模式下的虚拟机使用。如果 在Server模式下，它主要还有两大用途：一个是在1.5及之前的版本中与Parallel Scavenge收集器搭配使用
另外一个就是作为CMS收集器的后备预案，在并发收集发 生Concurrent Mode Failure的时候使用。

5 Parallel Old 收集器
Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理” 算法。这个收集器是在JDK 1.6中
才开始提供的，在此之前，新生代的Parallel Scavenge 收集器一直处于比较尴尬的状态。原因是，如果新生代选择了 Parallel
Scavenge收集器， 老年代除了 Serial Old (PSMarkSweep)收集器外e无选择（还记得上面说过Parallel Scavenge
收集器无法与CMS收集器配合工作吗？）。由干单线程的老年代Serial Old收 集器在服务端应用性能上的“拖累”，即便使用了 Parallel
Scavenge收集器也未必能在整 体应用上获得吞吐量最大化的效果，又因为老年代收集中无法充分利用服务器多CPU的 处理能力，在老年代很大
而且硬件比较高级的环境中，这种组合的淄铝可踔粱共灰欢 有ParNew加CMS的组合“给力”。直到Parallel Old收集器出现后，
“吞吐量优先”收集器终于有了比较名副其实的应 用组合，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加
Parallel Old收集器。

6 CMS收集器
CMS (Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收 集器。目前很大一部分的Java应用都集中在
互联网站或B/S系统的服务端上，这类应用 尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收 集器就非常符合
这类应用的需求。从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记一清除”算 法实现的，它的运作过程相对于前面几种
收集器来说要更复杂一些，整个过程分为4个 步骤，包括： 
□初始标记（CMS initial mark)
□并发标记（CMS concurrent mark)
□重新标记（CMS remark)
□并发清除（CMS concurrent sweep)
其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅 只是标记一下GC Roots能直接关联到的对象，
速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运 作
而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始 标记阶段稍长一些，但远比并发标记的时间短。
由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户 线程一起工作，所以总体上来说，CMS收集器的内存回收过程
是与用户线程一起并发地 执行的。

7 G1收集器
G1 (Garbage Fifst)收集器是当前收集器技术发展的最前沿成果，在JDK1.6_ UpdateM中提供了 Early Access版本
的G1收集器以供试用。在将来JDK 1.7正式发布 的时候，G1收集器很可能会有一个成熟的商用版本随之发布。这里只对G1收集器进行简单介绍
G1收集器是垃圾收集器理论进一步发展的产物，它与前面的CMS收集器相比有两 个显著的改进：一是G1收集器是基于“标记-整理”算法实现
的收集器，也就是说它 不会产生空间碎片，这对于长时间运行的应用系统来说非常重要。二是它可以非常精确 地控制停顿，既能让使用者明确指定
在一个长度为M毫秒的时间片段内，消耗在垃圾收 集上的时间不得超过N毫秒，这几乎已经是实时Java (RTSJ)的垃圾收集器的特征了。
G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于 它能够极力地避免全区域的垃圾收集，之前的收集器进行收集
的范围都是整个新生代或 老年代，而G1将整个Java堆（包括新生代、老年代）划分为多个大小固定的独立区域 (Region),并且跟踪这些
区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根 据允许的收集时间，优先回收垃圾最多的区域（这就是Garbage First名称
的来由）。区 域划分及有优先级的区域回收，保证了 G1收集器在有限的时间内可以获得最高的收集 效率。