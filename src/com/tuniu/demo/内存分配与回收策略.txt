Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。

对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过JIT编译后被拆 散为标量类型并间接地在栈上分配),对象主要
分配在新生代的Eden区上，如果启动 了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在 老
年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾 收集器组合，还有虚拟机中与内存相关的参数的设置。

1、对象优先在Eden分配

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配 时，虚拟机将发起一次Minor GC。
虚拟机提供了-XXi+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾 收集行为时打印内存回收日志，
并且在进程退出的时候输出当前内存各区域的分配情 况。通过-Xms20M、-Xmx20M和-XmnlOM这3个参数限制Java堆大小为20MB,
且不可扩展，其中10MB分配给新生代，剩下的10MB分配给老 年代。-XX:SurvivorRatio=8决定了新生代中Eden区
与一个Survivor区的空间比例 是8比1，从输出的结果也能清晰地看到“eden space 8192K、from space 
1024K、to space 1024K”的信息，新生代总可用空间为9216KB (Eden区+1个Survivor区的总 容量）。

注意作者多次提到的Minor GC和Full GC有什么不一样吗？
□新生代GC (Minor GC):指发生在新生代的垃圾收集动作，因为Java对象大多都具 备朝生夕灭的特性，
所以Minor GC非常频繁，一般回收速度也比较快。
□老年代GC (MajorGC/FullGC):指发生在老年代的GC,出现了 Major GC,经常 会伴随至少一次的Minor GC
(但非绝对的，在ParallelScavenge收集器的收集策略里 就有直接进行Major GC的策略选择过程）。MajorGC的
速度一般会比Minor GC馒10 倍以上。


2、大对象直接进入老年代
所谓大对象就是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组（笔者例子中的byte[]数组
就是典型的大对象）。大对象对虚拟机的内存 分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是
 遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易 导致内存还有不少空间时就提前触发垃圾收集
 以获取足够的连续空间来“安置”它们。虚拟机提供了一个 -XX:PretemireSizeThreshold参数，令大于这个设置值的
 对象直接 在老年代中分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝（复习一下新生代采用复制
 算法收集内存）。执行代码清单3-4中的testPretenureSizeThreshold()方法后，我们看到Eden空间 几乎没有被使用，
 而老年代10MB的空间被使用了 40%,也就是4MB的allocation 对象直接就分配在老年代中，这是因为
PretenureSizeThreshold被设置为3MB (就是 3145728B,这个参数不能与-Xmx之类的参数一样直接写3MB),
因此超过3MB的对 象都会直接在老年代中进行分配。
注意:PretenureSizeThreshold 参数只对 Serial 和 ParNew 两款收集器有效，Parallel Scavenge收集器不
认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇 到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。